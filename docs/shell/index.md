# SATELLITE シェルスタイルガイド

多くのSATELLITEメンバーによって執筆、改訂、保守されています。

---

## 目次

| セクション | 内容 |
|-----------|------|
| [背景](#背景) | [使用するシェル](#使用するシェル) - [シェルを使うべき場面](#シェルを使うべき場面) |
| [シェルファイルとインタープリタの呼び出し](#シェルファイルとインタープリタの呼び出し) | [ファイル拡張子](#ファイル拡張子) - [SUID/SGID](#suidsgid) |
| [環境](#環境) | [STDOUT vs STDERR](#stdout-vs-stderr) |
| [コメント](#コメント) | [ファイルヘッダー](#ファイルヘッダー) - [関数コメント](#関数コメント) - [実装コメント](#実装コメント) - [TODOコメント](#todoコメント) |
| [フォーマット](#フォーマット) | [インデント](#インデント) - [行の長さと長い文字列](#行の長さと長い文字列) - [パイプライン](#パイプライン) - [制御フロー](#制御フロー) - [case文](#case文) - [変数展開](#変数展開) - [クォート](#クォート) |
| [機能とバグ](#機能とバグ) | [ShellCheck](#shellcheck) - [コマンド置換](#コマンド置換) - [Test、`[ … ]`、`[[ … ]]`](#test----と---) - [文字列のテスト](#文字列のテスト) - [ファイル名のワイルドカード展開](#ファイル名のワイルドカード展開) - [Eval](#eval) - [配列](#配列) - [Whileへのパイプ](#whileへのパイプ) - [算術演算](#算術演算) - [エイリアス](#エイリアス) |
| [命名規則](#命名規則) | [関数名](#関数名) - [変数名](#変数名) - [定数と環境変数名](#定数環境変数とreadonly変数) - [ソースファイル名](#ソースファイル名) - [ローカル変数の使用](#ローカル変数の使用) - [関数の配置](#関数の配置) - [main](#main) |
| [コマンドの呼び出し](#コマンドの呼び出し) | [戻り値の確認](#戻り値の確認) - [組み込みコマンド vs 外部コマンド](#組み込みコマンド-vs-外部コマンド) |
| [迷ったときは：一貫性を保つ](#迷ったときは一貫性を保つ) | |

---

## 背景

### 使用するシェル

**実行可能ファイルに許可されるシェルスクリプト言語はBashのみです。**

実行可能ファイルは `#!/bin/bash` と最小限のフラグで開始しなければなりません。シェルオプションの設定には `set` を使用し、スクリプトを `bash script_name` として呼び出しても機能が壊れないようにしてください。

すべての実行可能シェルスクリプトを *bash* に限定することで、すべてのマシンにインストールされている一貫したシェル言語が得られます。特に、これはPOSIX互換性を追求したり「bashism」を避けたりする必要が一般的にないことを意味します。

上記の唯一の例外は、コーディング対象の制約によってやむを得ない場合です。例えば、一部のレガシーオペレーティングシステムや制約された実行環境では、特定のスクリプトにプレーンなBourneシェルが必要になることがあります。

### シェルを使うべき場面

**シェルは小さなユーティリティや単純なラッパースクリプトにのみ使用すべきです。**

シェルスクリプトは開発言語ではありませんが、SATELLITE全体でさまざまなユーティリティスクリプトの作成に使用されています。このスタイルガイドは、広範なデプロイメントにシェルの使用を推奨するものではなく、その使用を認識するためのものです。

いくつかのガイドライン：

- 主に他のユーティリティを呼び出し、比較的少ないデータ操作を行う場合、シェルはそのタスクに適した選択肢です。
- パフォーマンスが重要な場合は、シェル以外のものを使用してください。
- 100行を超えるスクリプトを書いている場合、または単純でない制御フローロジックを使用している場合は、*今すぐ*より構造化された言語で書き直すべきです。スクリプトは成長するものです。後でより時間のかかる書き直しを避けるために、早めに書き直してください。
- コードの複雑さを評価する際（例えば、言語を切り替えるかどうかを決定する際）、そのコードが作者以外の人にとっても容易に保守可能かどうかを考慮してください。

---

## シェルファイルとインタープリタの呼び出し

### ファイル拡張子

**実行可能ファイルには `.sh` 拡張子を付けるか、拡張子なしにすべきです。**

- 実行可能ファイルにソースファイルをリネームするビルドルールがある場合は、`.sh` 拡張子の使用が推奨されます。これにより、`foo.sh` のようなソースファイルと `foo` という名前のビルドルールという推奨される命名規則を使用できます。
- 実行可能ファイルがユーザーの `PATH` に直接追加される場合は、拡張子なしが推奨されます。プログラムを実行する際にそのプログラムがどの言語で書かれているかを知る必要はなく、シェルは拡張子を必要としないため、ユーザーが直接呼び出す実行可能ファイルには拡張子を使用しないことを推奨します。同時に、ソースファイルを直接デプロイするよりも、ビルドルールの出力をデプロイする方が望ましいかどうかも検討してください。
- 上記のいずれにも該当しない場合は、どちらの選択でも構いません。

**ライブラリには `.sh` 拡張子を付け、実行可能にすべきではありません。**

### SUID/SGID

**SUIDとSGIDはシェルスクリプトで*禁止*されています。**

シェルにはセキュリティ上の問題が多すぎるため、SUID/SGIDを許可するのに十分なセキュリティを確保することがほぼ不可能です。bashはSUIDでの実行を困難にしていますが、一部のプラットフォームでは依然として可能であるため、明示的に禁止しています。

昇格されたアクセスが必要な場合は `sudo` を使用してください。

---

## 環境

### STDOUT vs STDERR

**すべてのエラーメッセージは `STDERR` に出力すべきです。**

これにより、通常のステータスと実際の問題を分離しやすくなります。

エラーメッセージと他のステータス情報を出力する関数を用意することを推奨します。

```bash
err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
}

if ! do_something; then
  err "Unable to do_something"
  exit 1
fi
```

---

## コメント

### ファイルヘッダー

**各ファイルはその内容の説明で始めてください。**

すべてのファイルには、内容の簡単な概要を含むトップレベルのコメントが必要です。著作権表示と著者情報はオプションです。

例：

```bash
#!/bin/bash
#
# Perform hot backups of Oracle databases.
```

### 関数コメント

**明白かつ短い関数でない限り、関数ヘッダーコメントが必要です。ライブラリ内のすべての関数は、長さや複雑さに関わらず関数ヘッダーコメントが必要です。**

他の人がコードを読まずに、コメント（および提供されている場合はセルフヘルプ）を読むだけで、プログラムの使い方やライブラリ内の関数の使い方を学べるようにすべきです。

すべての関数ヘッダーコメントは、以下を使用して意図されたAPIの動作を記述すべきです：

- 関数の説明
- Globals：使用および変更されるグローバル変数のリスト
- Arguments：受け取る引数
- Outputs：STDOUTまたはSTDERRへの出力
- Returns：最後に実行されたコマンドのデフォルトの終了ステータス以外の戻り値

例：

```bash
#######################################
# Cleanup files from the backup directory.
# Globals:
#   BACKUP_DIR
#   ORACLE_SID
# Arguments:
#   None
#######################################
function cleanup() {
  ...
}

#######################################
# Get configuration directory.
# Globals:
#   SOMEDIR
# Arguments:
#   None
# Outputs:
#   Writes location to stdout
#######################################
function get_dir() {
  echo "${SOMEDIR}"
}

#######################################
# Delete a file in a sophisticated manner.
# Arguments:
#   File to delete, a path.
# Returns:
#   0 if thing was deleted, non-zero on error.
#######################################
function del_thing() {
  rm "$1"
}
```

### 実装コメント

**コードのトリッキーな部分、明白でない部分、興味深い部分、重要な部分にコメントを付けてください。**

これはSATELLITEの一般的なコーディングコメントの慣行に従います。すべてにコメントを付ける必要はありません。複雑なアルゴリズムや通常とは異なることを行っている場合は、短いコメントを入れてください。

### TODOコメント

**一時的なコード、短期的な解決策、または十分だが完璧ではないコードにはTODOコメントを使用してください。**

これは[C++ガイド](https://google.github.io/styleguide/cppguide.html#TODO_Comments)の慣例に準拠しています。

`TODO` は、すべて大文字の `TODO` 文字列の後に、`TODO` で参照されている問題について最もよく状況を把握している人の名前、メールアドレス、またはその他の識別子を含めるべきです。主な目的は、リクエストに応じて詳細を取得する方法を見つけるために検索できる一貫した `TODO` を持つことです。`TODO` は、参照された人がその問題を修正するという約束ではありません。したがって、`TODO` を作成する際は、ほぼ常にあなた自身の名前が記載されます。

例：

```bash
# TODO(mrmonkey): Handle the unlikely edge cases (bug ####)
```

---

## フォーマット

修正しているファイルに既にあるスタイルに従うべきですが、新しいコードには以下が要求されます。

### インデント

**2スペースでインデント。タブは使用しない。**

ブロック間に空行を使用して可読性を向上させてください。インデントは2スペースです。何をするにしても、タブは使用しないでください。既存のファイルについては、既存のインデントに忠実に従ってください。

**例外：** タブの使用が許可される唯一の例外は、`<<-` タブインデントされた[ヒアドキュメント](https://www.gnu.org/software/bash/manual/html_node/Redirections.html#Here-Documents)の本体です。

### 行の長さと長い文字列

**最大行長は80文字です。**

80文字を超えるリテラル文字列を書く必要がある場合は、可能であれば[ヒアドキュメント](https://www.gnu.org/software/bash/manual/html_node/Redirections.html#Here-Documents)または埋め込み改行で行うべきです。

80文字を超え、合理的に分割できない単語は許容されますが、可能な場合は、それらの項目を独自の行に配置するか、変数に格納すべきです。例としては、ファイルパスやURL、特に文字列マッチング（`grep` など）での保守性が重要な場合が含まれます。

```bash
# ヒアドキュメントを使用する
cat <<END
I am an exceptionally long
string.
END

# 埋め込み改行も可
long_string="I am an exceptionally
long string."

long_file="/i/am/an/exceptionally/loooooooooooooooooooooooooooooooooooooooooooooooooooong_file"

long_string_with_long_file="i am including an exceptionally \
/very/long/file\
 in this long string."

# 長いファイルを短い変数名に変換し、行の折り返しをきれいにする
long_string_alt="i am an including an exceptionally ${long_file} in this long\
 string"
```

```bash
# 行に例外が含まれているからといって、行の残りの部分を
# 通常通り折り返さなくてよいわけではない

bad_long_string_with_long_file="i am including an exceptionally /very/long/file in this long string."
```

### パイプライン

**パイプラインが1行に収まらない場合は、1パイプセグメントごとに1行に分割すべきです。**

パイプラインが1行に収まる場合は、1行に書くべきです。

収まらない場合は、パイプ1セグメントごとに1行に分割し、パイプを新しい行に置き、パイプの次のセクションを2スペースインデントすべきです。`\` は行の継続を示すために一貫して使用すべきです。これは `|` を使用して結合されたコマンドのチェーンと、`||` および `&&` を使用した論理合成の両方に適用されます。

```bash
# すべて1行に収まる
command1 | command2

# 長いコマンド
command1 \
  | command2 \
  | command3 \
  | command4
```

これは、特に行が両方を使用している場合に、パイプラインと通常の長いコマンドの継続を区別する際の可読性に役立ちます。

コメントはパイプライン全体の前に配置する必要があります。コメントとパイプラインが大きく複雑な場合は、ヘルパー関数を使用して低レベルの詳細を分離することを検討する価値があります。

### 制御フロー

**`; then` と `; do` は `if`、`for`、または `while` と同じ行に置いてください。**

シェルの制御フロー文は少し異なりますが、関数を宣言する際の中括弧と同じ原則に従います。つまり、`; then` と `; do` は `if`/`for`/`while`/`until`/`select` と同じ行に置くべきです。`else` は独自の行に置き、閉じ文（`fi` と `done`）は開始文と垂直に揃えて独自の行に置くべきです。

例：

```bash
# 関数内の場合、ループ変数がグローバル環境に漏れるのを
# 避けるためにlocalとして宣言することを忘れないでください：
local dir
for dir in "${dirs_to_cleanup[@]}"; do
  if [[ -d "${dir}/${SESSION_ID}" ]]; then
    log_date "Cleaning up old files in ${dir}/${SESSION_ID}"
    rm "${dir}/${SESSION_ID}/"* || error_message
  else
    mkdir -p "${dir}/${SESSION_ID}" || error_message
  fi
done
```

forループで[`in "$@"` を省略する](https://www.gnu.org/software/bash/manual/html_node/Looping-Constructs.html#index-for)ことは可能ですが、明確さのために一貫してそれを含めることを推奨します。

```bash
for arg in "$@"; do
  echo "argument: ${arg}"
done
```

### case文

- 選択肢を2スペースでインデントする。
- 1行の選択肢には、パターンの閉じ括弧の後と `;;` の前にスペースが必要。
- 長いまたは複数コマンドの選択肢は、パターン、アクション、`;;` を別々の行に分けて複数行にすべき。

マッチング式は `case` と `esac` から1レベルインデントします。複数行のアクションはさらに1レベルインデントします。一般的に、マッチング式をクォートする必要はありません。パターン式の前に開き括弧を付けるべきではありません。`;&` と `;;&` の表記は避けてください。

```bash
case "${expression}" in
  a)
    variable="..."
    some_command "${variable}" "${other_expr}" ...
    ;;
  absolute)
    actions="relative"
    another_command "${actions}" "${other_expr}" ...
    ;;
  *)
    error "Unexpected expression '${expression}'"
    ;;
esac
```

単純なコマンドは、式が読みやすい限り、パターンと `;;` を同じ行に書いてもかまいません。これは1文字のオプション処理に適していることが多いです。アクションが1行に収まらない場合は、パターンを独自の行に置き、次にアクション、そして `;;` も独自の行に置きます。アクションと同じ行にある場合は、パターンの閉じ括弧の後にスペースを1つ、`;;` の前にもスペースを1つ入れてください。

```bash
verbose='false'
aflag=''
bflag=''
files=''
while getopts 'abf:v' flag; do
  case "${flag}" in
    a) aflag='true' ;;
    b) bflag='true' ;;
    f) files="${OPTARG}" ;;
    v) verbose='true' ;;
    *) error "Unexpected option ${flag}" ;;
  esac
done
```

### 変数展開

**優先順位順に：既存のコードとの一貫性を保つ、変数をクォートする、`"$var"` よりも `"${var}"` を推奨する。**

これらは強く推奨されるガイドラインですが、必須の規制ではありません。ただし、推奨であって必須ではないという事実は、軽視してよいという意味ではありません。

優先順位順に列挙します：

- 既存のコードとの一貫性を保つ。
- 変数をクォートする。以下の[クォートセクション](#クォート)を参照。
- 厳密に必要な場合や深い混乱を避ける場合を除き、1文字のシェル特殊変数/位置パラメータを波括弧で囲まない。

その他のすべての変数は波括弧で囲むことを推奨します。

```bash
# *推奨*されるケースのセクション

# 「特殊」変数の推奨スタイル：
echo "Positional: $1" "$5" "$3"
echo "Specials: !=$!, -=$-, _=$_. ?=$?, #=$# *=$* @=$@ \$=$$ ..."

# 波括弧が必要な場合：
echo "many parameters: ${10}"

# 混乱を避けるための波括弧：
# 出力は "a0b0c0"
set -- a b c
echo "${1}0${2}0${3}0"

# 他の変数の推奨スタイル：
echo "PATH=${PATH}, PWD=${PWD}, mine=${some_var}"
while read -r f; do
  echo "file=${f}"
done < <(find /tmp)
```

```bash
# *非推奨*のケースのセクション

# クォートされていない変数、波括弧なしの変数、
# 波括弧で囲まれた1文字のシェル特殊変数
echo a=$avar "b=$bvar" "PID=${$}" "${1}"

# 混乱を招く使用："${1}0${2}0${3}0" として展開され、
# "${10}${20}${30}" ではない
set -- a b c
echo "$10$20$30"
```

注意：`${var}` で波括弧を使用することはクォートの形式では*ありません*。「ダブルクォート」も*合わせて*使用する必要があります。

### クォート

- 慎重なクォートなし展開が必要な場合やシェル内部の整数の場合を除き、変数、コマンド置換、スペース、またはシェルメタ文字を含む文字列は常にクォートする。
- リスト、特にコマンドラインフラグの安全なクォートには配列を使用する。以下の[配列](#配列)を参照。
- 整数として定義されるシェル内部のreadonlyな[特殊変数](https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html)：`$?`、`$#`、`$$`、`$!` のクォートはオプション。一貫性のため、`PPID` などの「名前付き」内部整数変数のクォートを推奨する。
- 「単語」である文字列（コマンドオプションやパス名とは対照的に）のクォートを推奨する。
- `[[ … ]]` でのパターンマッチのクォートルールに注意する。以下の[Test、`[ … ]`、`[[ … ]]`](#test----と---)セクションを参照。
- メッセージやログで引数を文字列に単純に追加するなどの特定の理由がない限り、`$*` ではなく `"$@"` を使用する。

```bash
# 'シングル'クォートは置換が不要であることを示す。
# "ダブル"クォートは置換が必要/許容されることを示す。

# 単純な例

# "コマンド置換をクォートする"
# "$() "内にネストされたクォートはエスケープ不要。
flag="$(some_command and its args "$@" 'quoted separately')"

# "変数をクォートする"
echo "${flag}"

# クォートされた展開を持つ配列をリストに使用する。
declare -a FLAGS
FLAGS=( --foo --bar='baz' )
readonly FLAGS
mybinary "${FLAGS[@]}"

# 内部整数変数はクォートしなくてもよい。
if (( $# > 3 )); then
  echo "ppid=${PPID}"
fi

# "リテラル整数は決してクォートしない"
value=32
# "コマンド置換をクォートする"、整数を期待していても
number="$(generate_number)"

# "単語のクォートを推奨する"、必須ではない
readonly USE_INTEGER='true'

# "シェルメタ文字をクォートする"
echo 'Hello stranger, and well met. Earn lots of $$$'
echo "Process $$: Done making \$\$\$."

# "コマンドオプションやパス名"
# ($1 にはここで値が含まれていると仮定)
grep -li Hugo /dev/null "$1"

# より複雑な例
# "変数をクォートする、そうでないと証明されない限り": ccs は空の可能性がある
git send-email --to "${reviewers}" ${ccs:+"--cc" "${ccs}"}

# 位置パラメータの注意: $1 は未設定の可能性がある
# シングルクォートは正規表現をそのまま維持する。
grep -cP '([Ss]pecial|\|?characters*)$' ${1:+"$1"}

# 引数を渡す場合、
# "$@" はほぼ常に正しく、
# $* はほぼ常に間違い：
#
# * $* と $@ はスペースで分割し、スペースを含む引数を壊し、
#   空文字列を削除する。
# * "$@" は引数をそのまま保持するため、引数が
#   提供されなければ引数は渡されない。
#   これはほとんどの場合、引数を渡す際に使用すべきもの。
# * "$*" は1つの引数に展開され、すべての引数が
#   （通常は）スペースで結合される。
#   引数が提供されなければ1つの空文字列が渡される。
#
# 詳しくは以下を参照：
# https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html
# https://mywiki.wooledge.org/BashGuide/Arrays

(set -- 1 "2 two" "3 three tres"; echo $#; set -- "$*"; echo "$#, $@")
(set -- 1 "2 two" "3 three tres"; echo $#; set -- "$@"; echo "$#, $@")
```

---

## 機能とバグ

### ShellCheck

[ShellCheckプロジェクト](https://www.shellcheck.net/)は、シェルスクリプトの一般的なバグと警告を特定します。大小を問わずすべてのスクリプトに推奨されます。

### コマンド置換

**バッククォートの代わりに `$(command)` を使用してください。**

ネストされたバッククォートでは内側のバッククォートを `\` でエスケープする必要があります。`$(command)` 形式はネストしても変わらず、読みやすくなります。

例：

```bash
# 推奨：
var="$(command "$(command1)")"
```

```bash
# 非推奨：
var="`command \`command1\``"
```

### Test、`[ … ]`、と `[[ … ]]`

**`[[ … ]]` は `[ … ]`、`test`、`/usr/bin/[` よりも推奨されます。**

`[[ … ]]` は `[[` と `]]` の間でパス名展開やワード分割が行われないため、エラーが減ります。さらに、`[[ … ]]` はパターンマッチングと正規表現マッチングを許可しますが、`[ … ]` ではできません。

```bash
# これは左の文字列が英数字文字クラスの文字に続いて
# "name"文字列で構成されていることを確認する。
# 注意: RHSはここでクォートすべきではない。
if [[ "filename" =~ ^[[:alnum:]]+name ]]; then
  echo "Match"
fi

# これは正確なパターン "f*" にマッチする（このケースではマッチしない）
if [[ "filename" == "f*" ]]; then
  echo "Match"
fi
```

```bash
# これは f* がカレントディレクトリの内容に展開されるため、
# "too many arguments" エラーが発生する。`[` は `==` をサポートせず
# `=` のみサポートするため "unexpected operator" エラーも発生する可能性がある。
if [ "filename" == f* ]; then
  echo "Match"
fi
```

詳細については、[Bash FAQ](http://tiswww.case.edu/php/chet/bash/FAQ) の E14 を参照してください。

### 文字列のテスト

**可能な場合は、フィラー文字の代わりにクォートを使用してください。**

Bashはテスト内で空文字列を処理できるほどスマートです。したがって、コードがはるかに読みやすくなるため、フィラー文字の代わりに空/非空文字列のテストを使用してください。

```bash
# こうしてください：
if [[ "${my_var}" == "some_string" ]]; then
  do_something
fi

# -z（文字列長がゼロ）と -n（文字列長がゼロでない）は
# 空文字列のテストよりも推奨される
if [[ -z "${my_var}" ]]; then
  do_something
fi

# これはOK（空の側にクォートを確保する）だが、推奨ではない：
if [[ "${my_var}" == "" ]]; then
  do_something
fi
```

```bash
# こうしないでください：
if [[ "${my_var}X" == "some_stringX" ]]; then
  do_something
fi
```

何をテストしているかの混乱を避けるために、明示的に `-z` または `-n` を使用してください。

```bash
# こうしてください
if [[ -n "${my_var}" ]]; then
  do_something
fi
```

```bash
# こうしないでください
if [[ "${my_var}" ]]; then
  do_something
fi
```

明確さのために、両方とも動作しますが、`=` ではなく `==` を等値比較に使用してください。前者は `[[` の使用を促し、後者は代入と混同される可能性があります。ただし、`[[ … ]]` 内で `<` と `>` を使用する場合は注意してください。これらは辞書順比較を行います。数値比較には `(( … ))` または `-lt` と `-gt` を使用してください。

```bash
# こうしてください
if [[ "${my_var}" == "val" ]]; then
  do_something
fi

if (( my_var > 3 )); then
  do_something
fi

if [[ "${my_var}" -gt 3 ]]; then
  do_something
fi
```

```bash
# こうしないでください
if [[ "${my_var}" = "val" ]]; then
  do_something
fi

# おそらく意図しない辞書順比較
if [[ "${my_var}" > 3 ]]; then
  # 4ではtrue、22ではfalse
  do_something
fi
```

### ファイル名のワイルドカード展開

**ファイル名のワイルドカード展開を行う際は、明示的なパスを使用してください。**

ファイル名は `-` で始まる可能性があるため、`*` の代わりに `./*` でワイルドカードを展開する方がはるかに安全です。

```bash
# ディレクトリの内容は以下の通り：
# -f  -r  somedir  somefile

# ほぼすべてを強制的に削除してしまう
psa@bilby$ rm -v *
removed directory: `somedir'
removed `somefile'
```

```bash
# こうすべき：
psa@bilby$ rm -v ./*
removed `./-f'
removed `./-r'
rm: cannot remove `./somedir': Is a directory
removed `./somefile'
```

### Eval

**`eval` は避けるべきです。**

evalは代入に使用される際に入力を変更し、それらの変数が何であったかを確認することを不可能にしたまま変数を設定できます。

```bash
# これは何を設定するのか？
# 成功したか？部分的に？全体的に？
eval $(set_my_variables)

# 返された値の1つにスペースが含まれていたらどうなるか？
variable="$(eval some_function)"
```

### 配列

**Bash配列はリストの要素を格納するために使用すべきであり、クォートの複雑さを避けるためです。** これは特に引数リストに適用されます。配列はより複雑なデータ構造を容易にするために使用すべきではありません（前述の[シェルを使うべき場面](#シェルを使うべき場面)を参照）。

配列は文字列の順序付きコレクションを格納し、コマンドやループの個別の要素に安全に展開できます。

複数のコマンド引数に単一の文字列を使用することは避けるべきです。著者が `eval` を使用したり、文字列内にクォートをネストしようとしたりすることにつながり、信頼性がなく読みにくい結果となり、不必要な複雑さをもたらします。

```bash
# 配列は括弧を使用して代入され、
# +=( ... ) で追加できる
declare -a flags
flags=(--foo --bar='baz')
flags+=(--greeting="Hello ${name}")
mybinary "${flags[@]}"
```

```bash
# シーケンスに文字列を使用しないでください
flags='--foo --bar=baz'
flags+=' --greeting="Hello world"'  # これは意図通りに動作しない
mybinary ${flags}
```

```bash
# コマンド展開は配列ではなく単一の文字列を返す。
# 配列の代入でクォートなし展開を避けてください。
# コマンド出力に特殊文字やホワイトスペースが
# 含まれている場合、正しく動作しません。

# これはリスト出力を文字列に展開し、特殊キーワード展開を行い、
# ホワイトスペースで分割する。その後で初めて単語のリストになる。
# lsコマンドはユーザーのアクティブな環境に基づいて
# 動作を変更する可能性もある！
declare -a files=($(ls /directory))

# get_argumentsはすべてをSTDOUTに書き込むが、引数のリストに
# なる前に上記と同じ展開プロセスを経る。
mybinary $(get_arguments)
```

#### 配列の利点

- 配列を使用すると、クォートの意味を混乱させることなくリストを扱えます。逆に、配列を使用しないと、文字列内にクォートをネストしようとする誤った試みにつながります。
- 配列を使用すると、ホワイトスペースを含む文字列を含む任意の文字列のシーケンス/リストを安全に格納できます。

#### 配列の欠点

配列を使用すると、スクリプトの複雑さが増すリスクがあります。

#### 配列の判断

配列はリストを安全に作成して渡すために使用すべきです。特に、コマンド引数のセットを構築する際は、クォートの問題を避けるために配列を使用してください。クォートされた展開 `"${array[@]}"` を使用して配列にアクセスしてください。ただし、より高度なデータ操作が必要な場合は、シェルスクリプトの使用自体を避けるべきです。[上記](#シェルを使うべき場面)を参照してください。

### Whileへのパイプ

**`while` へのパイプよりも、プロセス置換または `readarray` 組み込みコマンド（bash4+）を使用してください。** パイプはサブシェルを作成するため、パイプライン内で変更された変数は親シェルに伝播しません。

`while` へのパイプ内の暗黙のサブシェルは、追跡が困難な微妙なバグを引き起こす可能性があります。

```bash
last_line='NULL'
your_command | while read -r line; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done

# これは常に 'NULL' を出力する！
echo "${last_line}"
```

プロセス置換もサブシェルを作成します。ただし、`while`（または他のコマンド）をサブシェルに入れずに、サブシェルから `while` へのリダイレクトが可能です。

```bash
last_line='NULL'
while read line; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done < <(your_command)

# これはyour_commandからの最後の非空行を出力する
echo "${last_line}"
```

あるいは、`readarray` 組み込みコマンドを使用してファイルを配列に読み込み、配列の内容をループすることもできます。（上記と同じ理由で）パイプではなく `readarray` でプロセス置換を使用する必要がありますが、ループの入力生成がループの後ではなく前に配置されるという利点があります。

```bash
last_line='NULL'
readarray -t lines < <(your_command)
for line in "${lines[@]}"; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done
echo "${last_line}"
```

> 注意：`for var in $(...)` のように出力をイテレートするためにforループを使用する場合は注意してください。出力は行ごとではなくホワイトスペースで分割されます。出力に予期しないホワイトスペースが含まれないことがわかっている場合もありますが、これが明白でない場合や可読性を向上させない場合（`$(...)` 内の長いコマンドなど）は、`while read` ループまたは `readarray` の方が安全で明確なことが多いです。

### 算術演算

**`let`、`$[ … ]`、`expr` ではなく、常に `(( … ))` または `$(( … ))` を使用してください。**

`$[ … ]` 構文、`expr` コマンド、`let` 組み込みコマンドは決して使用しないでください。

`<` と `>` は `[[ … ]]` 式内では数値比較を行いません（代わりに辞書順比較を行います。[文字列のテスト](#文字列のテスト)を参照）。数値比較には `[[ … ]]` を*まったく*使用せず、代わりに `(( … ))` を使用することを推奨します。

`(( … ))` をスタンドアロンの文として使用することは避け、式がゼロに評価されることにも注意してください。特に `set -e` が有効な場合、例えば `set -e; i=0; (( i++ ))` はシェルを終了させます。

```bash
# 文字列内で $(( ... )) を使用した単純な計算
echo "$(( 2 + 2 )) is 4"

# テスト用の算術比較
if (( a < b )); then
  ...
fi

# 変数に代入される計算
(( i = 10 * j + 400 ))
```

```bash
# この形式は非ポータブルで非推奨
i=$[2 * 10]

# 見た目に反して、'let' は宣言キーワードではないため、
# クォートされていない代入はグロビングとワード分割の対象になる。
# 簡潔さのために 'let' を避け、(( ... )) を使用する
let i="2 + 2"

# expr ユーティリティは外部プログラムであり、シェル組み込みではない
i=$( expr 4 + 4 )

# expr を使用する際もクォートはエラーを起こしやすい
i=$( expr 4 '*' 4 )
```

スタイル上の考慮を別にすれば、シェルの組み込み算術演算は `expr` よりも何倍も高速です。

変数を使用する場合、`$(( … ))` 内では `${var}`（および `$var`）形式は不要です。シェルは `var` を自動的に探し出すため、`${…}` を省略するとコードがきれいになります。これは常に波括弧を使用するという前述のルールと若干矛盾するため、推奨にとどめます。

```bash
# 注意: 可能な場合は変数を整数として宣言し、
# グローバル変数よりもローカル変数を推奨する。
local -i hundred="$(( 10 * 10 ))"
declare -i five="$(( 10 / 2 ))"

# 変数 "i" を3増やす。
# 注意:
#  - ${i} や $i は書かない。
#  - (( の後と )) の前にスペースを入れる。
(( i += 3 ))

# 変数 "i" を5減らす：
(( i -= 5 ))

# 複雑な計算を行う。
# 通常の算術演算子の優先順位が適用される。
hr=2
min=5
sec=30
echo "$(( hr * 3600 + min * 60 + sec ))"  # 期待通り 7530 を出力
```

### エイリアス

`.bashrc` ファイルでは一般的に見られますが、**エイリアスはスクリプトでは避けるべきです。** [Bashマニュアル](https://www.gnu.org/software/bash/manual/html_node/Aliases.html)が述べているように：

> ほぼすべての目的において、シェル関数がエイリアスよりも推奨されます。

エイリアスは内容を慎重にクォートしエスケープする必要があり、ミスに気づきにくいため、扱いが面倒です。

```bash
# これはエイリアスが定義された時に $RANDOM を一度評価するため、
# echoされる文字列は呼び出しごとに同じになる
alias random_name="echo some_prefix_${RANDOM}"
```

関数はエイリアスの機能のスーパーセットを提供し、常に推奨されます。

```bash
random_name() {
  echo "some_prefix_${RANDOM}"
}

# エイリアスとは異なり、関数の引数は $@ でアクセスする
fancy_ls() {
  ls -lh "$@"
}
```

---

## 命名規則

### 関数名

**小文字で、単語をアンダースコアで区切る。ライブラリは `::` で区切る。関数名の後に括弧が必要。`function` キーワードはオプションだが、プロジェクト全体で一貫して使用すること。**

単一の関数を書く場合は、小文字で単語をアンダースコアで区切ってください。パッケージを書く場合は、パッケージ名を `::` で区切ってください。ただし、対話的に使用することを意図した関数は、bashの自動補完を混乱させる可能性があるため、コロンの使用を避けることができます。

中括弧は関数名と同じ行に置き（SATELLITEの他の言語と同様）、関数名と括弧の間にスペースを入れないでください。

```bash
# 単一の関数
my_func() {
  ...
}

# パッケージの一部
mypackage::my_func() {
  ...
}
```

関数名の後に "()" がある場合、`function` キーワードは冗長ですが、関数の迅速な識別に役立ちます。

### 変数名

**関数名と同じルールです。**

ループの変数名は、ループしている対象の変数に合わせて同様に命名すべきです。

```bash
for zone in "${zones[@]}"; do
  something_with "${zone}"
done
```

### 定数、環境変数、とreadonly変数

**定数と環境にエクスポートされるものは大文字で、アンダースコアで区切り、ファイルの先頭で宣言すべきです。**

```bash
# 定数
readonly PATH_TO_FILES='/some/path'

# 定数かつ環境にエクスポート
declare -xr ORACLE_SID='PROD'
```

明確さのために、同等の `declare` コマンドよりも `readonly` または `export` を推奨します。以下のように順次行うこともできます：

```bash
# 定数
readonly PATH_TO_FILES='/some/path'
export PATH_TO_FILES
```

実行時や条件分岐内で定数を設定してもかまいませんが、その直後にreadonlyにすべきです。

```bash
ZIP_VERSION="$(dpkg --status zip | sed -n 's/^Version: //p')"
if [[ -z "${ZIP_VERSION}" ]]; then
  ZIP_VERSION="$(pacman -Q --info zip | sed -n 's/^Version *: //p')"
fi
if [[ -z "${ZIP_VERSION}" ]]; then
  handle_error_and_quit
fi
readonly ZIP_VERSION
```

### ソースファイル名

**小文字で、必要に応じて単語をアンダースコアで区切る。**

これはSATELLITEの他のコードスタイルとの一貫性のためです：`maketemplate` または `make_template`。`make-template` ではありません。

### ローカル変数の使用

**関数固有の変数は `local` で宣言してください。**

`local` を使用して宣言することで、ローカル変数が関数とその子でのみ見えるようにしてください。これにより、グローバル名前空間の汚染を避け、関数外で意味を持つ可能性のある変数を不注意に設定することを防ぎます。

代入値がコマンド置換によって提供される場合、宣言と代入は別の文にしなければなりません。`local` 組み込みコマンドがコマンド置換からの終了コードを伝播しないためです。

```bash
my_func2() {
  local name="$1"

  # 宣言と代入を別の行にする：
  local my_var
  my_var="$(my_func)"
  (( $? == 0 )) || return

  ...
}
```

```bash
my_func2() {
  # こうしないでください：
  # $? は 'local' の終了コードを含むため、my_func のものではなく、常にゼロになる
  local my_var="$(my_func)"
  (( $? == 0 )) || return

  ...
}
```

### 関数の配置

**すべての関数を定数の直下にまとめて配置してください。** 関数の間に実行可能コードを隠さないでください。そうするとコードが追いにくくなり、デバッグ時に不快なサプライズを引き起こします。

関数がある場合は、ファイルの先頭近くにまとめてください。インクルード、`set` 文、定数の設定のみが関数の宣言前に行えます。

### main

**少なくとも1つの他の関数を含む十分な長さのスクリプトには、`main` という名前の関数が必要です。**

プログラムの開始点を容易に見つけるために、メインプログラムを最も下の関数として `main` という名前の関数に入れてください。これにより、コードベースの残りの部分との一貫性が得られ、より多くの変数を `local` として定義できます（メインコードが関数でない場合は不可能）。ファイルの最後のコメントでない行は `main` の呼び出しであるべきです：

```bash
main "$@"
```

当然ながら、単なる直線的なフローの短いスクリプトでは、`main` は過剰であり、不要です。

---

## コマンドの呼び出し

### 戻り値の確認

**常に戻り値を確認し、情報のある戻り値を提供してください。**

パイプされていないコマンドの場合、`$?` を使用するか、`if` 文で直接確認して、シンプルに保ってください。

例：

```bash
if ! mv "${file_list[@]}" "${dest_dir}/"; then
  echo "Unable to move ${file_list[*]} to ${dest_dir}" >&2
  exit 1
fi

# または
mv "${file_list[@]}" "${dest_dir}/"
if (( $? != 0 )); then
  echo "Unable to move ${file_list[*]} to ${dest_dir}" >&2
  exit 1
fi
```

Bashにはパイプのすべての部分からのリターンコードを確認できる `PIPESTATUS` 変数もあります。パイプ全体の成功または失敗のみを確認する必要がある場合は、以下で十分です：

```bash
tar -cf - ./* | ( cd "${dir}" && tar -xf - )
if (( PIPESTATUS[0] != 0 || PIPESTATUS[1] != 0 )); then
  echo "Unable to tar files to ${dir}" >&2
fi
```

ただし、`PIPESTATUS` は他のコマンドを実行するとすぐに上書きされるため、パイプ内のどこでエラーが発生したかに基づいて異なる処理を行う必要がある場合は、コマンドの実行直後に `PIPESTATUS` を別の変数に代入する必要があります（`[` はコマンドであり `PIPESTATUS` を消去することを忘れないでください）。

```bash
tar -cf - ./* | ( cd "${DIR}" && tar -xf - )
return_codes=( "${PIPESTATUS[@]}" )
if (( return_codes[0] != 0 )); then
  do_something
fi
if (( return_codes[1] != 0 )); then
  do_something_else
fi
```

### 組み込みコマンド vs 外部コマンド

**シェル組み込みコマンドの呼び出しと別プロセスの呼び出しの選択肢がある場合、組み込みを選択してください。**

`bash` が提供する[*パラメータ展開*](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)機能などの組み込みの使用を推奨します。これはより効率的で、堅牢で、ポータブルです（特に `sed` のようなものと比較した場合）。[`=~` 演算子](https://www.gnu.org/software/bash/manual/html_node/Conditional-Constructs.html#index-_005b_005b)も参照してください。

例：

```bash
# 推奨：
addition="$(( X + Y ))"
substitution="${string/#foo/bar}"
if [[ "${string}" =~ foo:(\d+) ]]; then
  extraction="${BASH_REMATCH[1]}"
fi
```

```bash
# 非推奨：
addition="$(expr "${X}" + "${Y}")"
substitution="$(echo "${string}" | sed -e 's/^foo/bar/')"
extraction="$(echo "${string}" | sed -e 's/foo:\([0-9]\)/\1/')"
```

---

## 迷ったときは：一貫性を保つ

コードベース全体で1つのスタイルを一貫して使用することで、他の（より重要な）問題に集中できます。一貫性は自動化も可能にします。多くの場合、「一貫性を保つ」に帰属されるルールは「1つを選んで悩むのをやめる」に帰結します。これらの点で柔軟性を許容する潜在的な価値は、人々がそれらについて議論するコストに勝りません。

ただし、一貫性には限界があります。明確な技術的議論や長期的な方向性がない場合の良いタイブレーカーです。一貫性は一般的に、新しいスタイルの利点やコードベースが時間の経過とともに新しいスタイルに収束する傾向を考慮せずに、古いスタイルで物事を行うことの正当化として使用すべきではありません。
